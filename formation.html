<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TLK ‚Äì Formation Builder</title>
<style>
  :root{
    --bg:#0b1220; --panel:#0f172a; --muted:#94a3b8; --text:#e5e7eb; --accent:#22c55e; --accent2:#38bdf8; --line:#1f2937;
    --cardW:112px; --cardH:158px;  /* adjust once and the pitch scales */
    --gap:12px;
    --pitchW: 720px; /* exact pitch width; adjust to taste */
    --pitchH: 850px;
    --sideInset: 20%;   /* ‚Üê move this to match your sketch */
    --topBoxTop: 0%;     /* distance from top edge to top box */
    --topBoxH: 30%;      /* height of top box */
    --botBoxBottom: 0%;  /* distance from bottom edge to bottom box */
    --botBoxH: 30%;      /* height of bottom box ‚Äì make this bigger for GK */
    --centreDia: 20%;    /* centre circle diameter */
    --gaWidthPct: 23.5%;   /* ‚âà real: 20.15m / 68m ‚âà 29.6% ‚Üí 30% looks right */
    --gaDepthPct: 7.5%;  /* ‚âà real: 5.5m / 105m ‚âà 5.24% ‚Üí 5.5% feels good */
    --gaTopTop:   0%;  /* distance from TOP goal line to top 6-yd box */
    --gaBotBottom: 0%;  /* distance from BOTTOM goal line to bottom 6-yd box */
    /* line strength (tweak colors/alpha to taste) */
    --lineSoft:  #e5e7eb66;   /* boxes */
    --lineWings: #e5e7eb66;   /* wing lines */
    --lineHalf:  #e5e7eb66;   /* half way */
  }
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
  .wrap{max-width:1200px;margin:0 auto;padding:20px}
  .panel{background:var(--panel);border:1px solid var(--line);border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.2);overflow:hidden}
  .hdr{display:flex;gap:16px;align-items:center;justify-content:space-between;padding:14px 16px;border-bottom:1px solid var(--line)}
  h1{font-size:18px;margin:0}
  .muted{color:var(--muted);font-size:12px}

  /* top controls */
  .row{display:flex;flex-wrap:wrap;gap:10px;align-items:center;padding:12px 16px;border-bottom:1px solid var(--line)}
  .input,select{background:#0b1220;border:1px solid #263042;color:var(--text);border-radius:10px;padding:8px 10px;font-size:14px}
  .btn{background:#2563eb;border:0;color:#fff;border-radius:10px;padding:8px 12px;font-weight:600;cursor:pointer}
  .btn.alt{background:#334155}
  .btn.danger{background:#b91c1c}

  /* main 2-column content: pitch left, inventory right */
  .content{
    display:grid; grid-template-columns: 1fr 360px; gap:14px; padding:12px 16px 16px 16px;
  }
  .side .inventory{ position:sticky; top:16px; max-height: calc(100vh - 150px); overflow:auto; border-left:1px solid var(--line); padding-left:14px }

  /* compact, dimmer pitch */
  .pitch-wrap{ display:flex; justify-content:center; }
  .pitch{
    width: var(--pitchW);               /* was calc(...) */
    height: var(--pitchH);              /* was calc(...) */
    background:#1a6b3c;                 /* dimmer green */
    border:2px solid var(--line);
    border-radius:14px;
    overflow:hidden;
    position:relative;
  }
  .pitch .box-top{
    position:absolute; left:var(--sideInset); right:var(--sideInset);
    top:var(--topBoxTop); height:var(--topBoxH);
    border:1px solid var(--lineSoft); border-radius:6px;
  }
  .pitch .box-bot{
    position:absolute; left:var(--sideInset); right:var(--sideInset);
    bottom:var(--botBoxBottom); height:var(--botBoxH);
    border:1px solid var(--lineSoft); border-radius:6px;
  }
  .pitch .wing-left{
    position:absolute; top:0; bottom:0; left:var(--wingX);
    width:2px; background:var(--lineWings);
  }
  .pitch .wing-right{
    position:absolute; top:0; bottom:0; right:var(--wingX);
    width:2px; background:var(--lineWings);
  }
  .pitch .half{
    position:absolute; left:0; right:0; top:50%;
    height:1px; background:var(--lineHalf);
  }
  .pitch .centre{
    position:absolute; left:50%; top:50%;
    width:var(--centreDia); aspect-ratio:1/1; transform:translate(-50%,-50%);
    border:1px solid var(--lineHalf); border-radius:50%;
  }

  /* 6-yard boxes (centered horizontally, independent of sideInset) */
  .pitch .ga-top,
  .pitch .ga-bot{
    position:absolute;
    left:50%; width:var(--gaWidthPct); height:var(--gaDepthPct);
    transform:translateX(-50%);
    border:1px solid var(--lineSoft); border-radius:2px;
  }

  .pitch .ga-top{ top:    var(--gaTopTop); }
  .pitch .ga-bot{ bottom: var(--gaBotBottom); }


  /* prevent text selection / scroll gestures blocking drag */
  .pitch{ -webkit-user-select:none; user-select:none; touch-action:none; }
  /* make sure slots sit above lines */
  #pitch .slot{ z-index:2; position:absolute;}
  #pitch .box-top, #pitch .box-bot, #pitch .wing-left, #pitch .wing-right,
  #pitch .half, #pitch .centre, #pitch .ga-top, #pitch .ga-bot { z-index:1; }
  
  

  /* subtle field lines */


  /* Base slot (empty state shows dashed border) */
  .slot{
    position:absolute;
    width:var(--cardW, 112px);
    height:var(--cardH, 158px);
    border:3px dashed #8A7FA6CC;
    border-radius:10px;
    box-sizing:border-box;
    padding:4px;                 /* only for EMPTY state */
    display:flex; align-items:center; justify-content:center;
    overflow:hidden;             /* clip image corners */
  }
  /* When a card is placed: remove frame + gap so image fills exactly */
  .slot.filled{
    border:0;
    padding:0;
  }
  /* Only glow empty targets on hover */
  .slot.hover:not(.filled){
    border-color:#B39DDB;
    box-shadow:0 0 0 3px #B39DDB55 inset;
  }
  /* Image sizing + rounded corners */
  .slot .thumb{
    width:100%;
    height:100%;
    object-fit:cover;
    border-radius:inherit;       /* match slot corners */
    opacity:0;                   /* hidden until filled */
    -webkit-user-drag: none;
    user-drag: none;
    pointer-events:none;
    transition:opacity .12s ease;
  }
  .slot.filled .thumb{ opacity:1; }
  .slot .lbl{ position:absolute; bottom:-16px; font-size:10px; color:#94a3b8 }
  /* hide slot labels but keep them in DOM for saving/loading */
  .slot .lbl{ display:none; }
  .slot.moveable{ cursor: move; }  /* when editing layout */
  #trash.hover{ outline:2px solid #ef4444; }  /* trash hover feedback */


  /* bench strip */
  .bench{display:flex; gap:8px; flex-wrap:wrap; padding:12px 16px}
  .bench .slot .lbl{ bottom:auto; top:-16px }
  .bench .slot{ position:relative; left:auto; top:auto; transform:none; }

  .manager .slot{ position:relative; left:auto; top:auto; transform:none; }


  /* inventory (side) */
  .filters{display:flex; gap:8px; flex-wrap:wrap; margin-bottom:8px}
  .grid{display:grid; grid-template-columns:repeat(auto-fill,minmax(108px,1fr)); gap:10px}
  .card{background:#0b1220;border:1px solid var(--line);border-radius:12px;overflow:hidden}
  .card[draggable="true"]{ cursor:grab }
  .card .thumb{aspect-ratio:3/4; width:100%; object-fit:cover; display:block}
  .card .meta{padding:6px 8px}
  .card .name{font-size:12px;font-weight:700}
  .card.dim{opacity:.35}
  .row-footer{display:flex;justify-content:space-between;align-items:center;margin-top:8px}


  .modal{ position:fixed; inset:0; display:none; place-items:center; z-index:50; }
  .modal.open{ display:grid; }
  .modal__backdrop{ position:absolute; inset:0; background:rgba(0,0,0,.6); }
  .modal__content{
    position:relative; background:#0f172a; border:1px solid #1f2937; border-radius:12px;
    padding:12px; max-width:min(92vw, 560px); box-shadow:0 10px 30px rgba(0,0,0,.4);
  }
  .modal__close{ position:absolute; top:6px; right:8px; background:#334155; color:#fff; border:0; border-radius:8px; padding:4px 8px; cursor:pointer }
  .modal__content img{ width:100%; height:auto; display:block; border-radius:8px; }
  .modal .meta{ margin-top:8px; color:#94a3b8; font-size:12px }

  /* Loader overlay */
  .busy{ position:fixed; inset:0; display:none; place-items:center; background:rgba(0,0,0,.35); z-index:60; }
  .busy.open{ display:grid; }
  .busy__box{ background:#0f172a; border:1px solid #1f2937; padding:16px 18px; border-radius:12px; box-shadow:0 10px 30px rgba(0,0,0,.4); display:flex; align-items:center; gap:12px; }
  .spinner{ width:26px; height:26px; border:3px solid #94a3b888; border-top-color:#38bdf8; border-radius:50%; animation:spin 1s linear infinite; }
  .busy__msg{ color:#e5e7eb; font-size:14px; }
  @keyframes spin{ to { transform: rotate(360deg);} }

  /* Tiny toast (top-right) */
  .toast{ position:fixed; right:12px; top:12px; background:#111827; color:#e5e7eb; border:1px solid #1f2937; padding:10px 12px; border-radius:10px; opacity:0; transform:translateY(-8px); transition:.2s; z-index:61; }
  .toast.show{ opacity:1; transform:translateY(0); }
  .toast.err{ background:#7f1d1d; border-color:#991b1b; }

  @media (max-width: 980px){
    .content{ grid-template-columns: 1fr; }
    .side .inventory{ position:relative; top:auto; max-height:none; border-left:0; padding-left:0; }
    .pitch{ width: min(100%, var(--pitchW)); height: var(--pitchH); }
  }
</style>
</head>
<body>
<div class="wrap">
  <div class="panel">
    <div class="hdr">
      <h1>TLK Formation Builder</h1>
      <div class="muted">Drag cards onto the pitch. No duplicates allowed. Right-click a slot to clear.</div>
    </div>

    <!-- Controls -->
    <div class="row">

      <!-- after -->
      <input id="user_id" class="input" placeholder="Discord ID (preferred) or @username" />
      <button class="btn" id="btnSearch">Load Inventory</button>
      <input id="fname" class="input" placeholder="Formation name (e.g., 433 ‚Äì Pressing)"/>
      <button class="btn" id="btnLoad">Load</button>
      <button class="btn alt" id="btnList">My Formations</button>
      <button class="btn" id="btnSave">Save</button>
      <button class="btn alt" id="btnClear">Clear</button>
      <button class="btn alt" id="btnEdit">Edit Layout</button>
      <button class="btn alt" id="btnGrid">Snap: On</button>
    </div>

    <!-- Main 2-column area -->
    <div class="content">
      <main>
        <!-- Pitch -->
        <div class="pitch-wrap">
          <div id="pitch" class="pitch" aria-live="polite">
            <div class="half"></div>
            <div class="box-top"></div>
            <div class="box-bot"></div>
            <div class="wing-left"></div>
            <div class="wing-right"></div>
            <div class="centre"></div>
            <div class="ga-top"></div>
            <div class="ga-bot"></div>
            <!-- Compact 4-3-3 layout (absolute in %) -->
            <!-- back line -->
            <div class="slot" data-slot="GK"  style="left:50%; top:90%; transform:translate(-50%,-50%)"><span class="lbl">GK</span><img class="thumb" alt=""/></div>
            <div class="slot" data-slot="LB"  style="left:10%; top:70%; transform:translate(-50%,-50%)"><span class="lbl">LB</span><img class="thumb" alt=""/></div>
            <div class="slot" data-slot="LCB" style="left:32%; top:79%; transform:translate(-50%,-50%)"><span class="lbl">LCB</span><img class="thumb" alt=""/></div>
            <div class="slot" data-slot="RCB" style="left:68%; top:79%; transform:translate(-50%,-50%)"><span class="lbl">RCB</span><img class="thumb" alt=""/></div>
            <div class="slot" data-slot="RB"  style="left:90%; top:70%; transform:translate(-50%,-50%)"><span class="lbl">RB</span><img class="thumb" alt=""/></div>
            <!-- midfield -->
            <div class="slot" data-slot="LCM" style="left:30%; top:40%; transform:translate(-50%,-50%)"><span class="lbl">LCM</span><img class="thumb" alt=""/></div>
            <div class="slot" data-slot="DM"  style="left:50%; top:60%; transform:translate(-50%,-50%)"><span class="lbl">DM</span><img class="thumb" alt=""/></div>
            <div class="slot" data-slot="RCM" style="left:70%; top:40%; transform:translate(-50%,-50%)"><span class="lbl">RCM</span><img class="thumb" alt=""/></div>
            <!-- forwards -->
            <div class="slot" data-slot="LW"  style="left:10%; top:30%; transform:translate(-50%,-50%)"><span class="lbl">LW</span><img class="thumb" alt=""/></div>
            <div class="slot" data-slot="ST"  style="left:50%; top:16%; transform:translate(-50%,-50%)"><span class="lbl">ST</span><img class="thumb" alt=""/></div>
            <div class="slot" data-slot="RW"  style="left:90%; top:30%; transform:translate(-50%,-50%)"><span class="lbl">RW</span><img class="thumb" alt=""/></div>
          </div>
        </div>

        <!-- Manager + Bench -->
        <div class="bench" id="bench">
          <div class="slot" data-slot="B1"><span class="lbl">B1</span><img class="thumb" alt=""/></div>
          <div class="slot" data-slot="B2"><span class="lbl">B2</span><img class="thumb" alt=""/></div>
          <div class="slot" data-slot="B3"><span class="lbl">B3</span><img class="thumb" alt=""/></div>
          <div class="slot" data-slot="B4"><span class="lbl">B4</span><img class="thumb" alt=""/></div>
          <div class="slot" data-slot="B5"><span class="lbl">B5</span><img class="thumb" alt=""/></div>
          <div class="slot" data-slot="B6"><span class="lbl">B6</span><img class="thumb" alt=""/></div>
          <div class="slot" data-slot="B7"><span class="lbl">B7</span><img class="thumb" alt=""/></div>
          <div class="slot" data-slot="B8"><span class="lbl">B8</span><img class="thumb" alt=""/></div>
          <div id="trash" class="panel" style="margin:0 16px 16px 16px; padding:10px; text-align:center; border:1px dashed #64748b;">
            üóë Drag here to remove from pitch
          </div>
        </div>
        <div class="bench" id="manager">
          <div class="bench-title">--Your Manager</div>
          <div class="manager">
            <div class="slot" data-slot="MANAGER" style="position:relative; left:auto; top:auto; transform:none;">
              <span class="lbl">Manager</span><img class="thumb" alt=""/>
            </div>
          </div>
        </div>

      </main>

      <!-- Inventory side -->
      <aside class="side">
        <div class="inventory">
          <div class="filters">
            <select id="rarity"><option value="ALL">Rarity: ALL</option><option>N</option><option>R</option><option>AR</option><option>SR</option><option>SSR</option></select>
            <select id="position"><option value="ALL">Position: ALL</option><option>GK</option><option>RB</option><option>LB</option><option>CB</option><option>DM</option><option>CM</option><option>AM</option><option>RW</option><option>LW</option><option>ST</option></select>
            <select id="club"><option value="ALL">Club: ALL</option></select>
          </div>
          <div style="display:flex; gap:8px; margin-bottom:8px">
            
            <button class="btn alt" id="btnRefresh">Refresh</button>
          </div>
          <div id="inv" class="grid" aria-live="polite"></div>
          <div class="row-footer" style="justify-content:space-between;align-items:center;margin-top:8px">
            <div class="muted">Placed: <span id="placedCount">0</span> / 20</div>
            <div class="muted" id="invPager">
              <button class="btn alt" id="pgPrev">Prev</button>
              <span class="muted" id="pgInfo">1 / 1</span>
              <button class="btn alt" id="pgNext">Next</button>
            </div>
            <div class="muted">Placed: <span id="placedCount">0</span> / 20</div>
            <div class="muted">üéü <span id="tickets">‚Äì</span> ‚Ä¢ ü™ô <span id="tokens">‚Äì</span></div>
          </div>
        </div>
      </aside>
    </div>

  </div>
</div>
<div id="cardModal" class="modal" aria-hidden="true">
  <div class="modal__backdrop" data-close></div>
  <div class="modal__content">
    <button class="modal__close" data-close>&times;</button>
    <img id="modalImg" alt="" />
    <div id="modalMeta" class="meta"></div>
  </div>
</div>
<div id="busy" class="busy" aria-hidden="true">
  <div class="busy__box">
    <div class="spinner"></div>
    <div id="busyMsg" class="busy__msg">Working‚Ä¶</div>
  </div>
</div>


<script>
/* ===== CONFIG ===== */
const API_BASE = 'https://the-last-kick.keithcheung129.workers.dev/api';

const API_KEY = localStorage.getItem('TLK_BROWSER_KEY') || ''; // or hardcode during dev

const ENFORCE_MANAGER = false; // toggle to true when you want the rule



/* ===== helpers ===== */
const $ = (id) => document.getElementById(id);
const safeOn = (id,evt,fn) => { const el=$(id); if(el) el.addEventListener(evt,fn); else console.warn('Missing #'+id); };
// safe value getter (never throws if the element is missing)
const v = (id, def='') => {
  const el = $(id);
  return (el && typeof el.value === 'string') ? el.value : def;
};

const getVal = (id, def='ALL') => {
  const el = document.getElementById(id);
  return (el ? el.value : def);
};
const U = s => String(s ?? '').toUpperCase();
// event binder (guarded) ‚Äì defines `on()` and `safeOn()`
// so either name will work across your code
const on = (id, evt, fn) => {
  const el = $(id);
  if (el) el.addEventListener(evt, fn);
  else console.warn('Missing #' + id);
};
  
const keyOf = (it) => `${it.card_id}::${it.serial ?? ''}`;

// Image cache: keyed by "card_id::serial" and also "card_id::"
const IMG_CACHE = new Map();
function cacheImage(it){
  const k = keyOf(it);
  if (it.image) IMG_CACHE.set(k, it.image);
  // also cache a serial-agnostic key (utilities, or when serial not set)
  const baseK = `${it.card_id}::`;
  if (it.image && !IMG_CACHE.has(baseK)) IMG_CACHE.set(baseK, it.image);
}



  
function startBusy(msg='Working‚Ä¶'){ const b=$('busy'); if(!b) return; b.classList.add('open'); const m=$('busyMsg'); if(m) m.textContent=msg; }
function stopBusy(){ const b=$('busy'); if(b) b.classList.remove('open'); }
function toast(msg, isErr=false){
  const t=document.createElement('div');
  t.className='toast'+(isErr?' err':'');
  t.textContent=msg; document.body.appendChild(t);
  requestAnimationFrame(()=>t.classList.add('show'));
  setTimeout(()=>{ t.classList.remove('show'); setTimeout(()=>t.remove(),200); }, 1800);
}
function setUiDisabled(dis){
  ['btnSearch','btnRefresh','btnSave','btnLoad','btnList','btnClear','btnEdit','btnGrid']
    .forEach(id=>{ const el=$(id); if(el) el.disabled=dis; });
}



function openCardModal(it){
  const m = document.getElementById('cardModal'); if (!m) return;
  const img = document.getElementById('modalImg');
  img.src = it.image || '';
  img.alt = it.name || it.card_id || '';
  const meta = [it.name, it.rarity, it.position || it.type, it.club, it.serial!=null?('#'+it.serial):'']
    .filter(Boolean).join(' ‚Ä¢ ');
  document.getElementById('modalMeta').textContent = meta;
  m.classList.add('open'); m.setAttribute('aria-hidden','false');
}
function closeCardModal(){
  const m = document.getElementById('cardModal'); if (!m) return;
  m.classList.remove('open'); m.setAttribute('aria-hidden','true');
}
document.addEventListener('click', (e)=>{
  if (e.target.matches('[data-close]')) closeCardModal();
});
document.addEventListener('keydown', (e)=>{
  if (e.key === 'Escape') closeCardModal();
});


  

/* ===== Layout edit & grid snap config ===== */
let editingLayout = false;       // toggled by "Edit Layout"
let SNAP_GRID = true;            // toggled by "Snap: On/Off"
const GRID = { xStepPct: 2, yStepPct: 2 }; // snap step (% of pitch); tweak for finer/coarser grid

const snapPct = (pct, step) => Math.round(pct / step) * step;

// enable/disable slot-as-card dragging depending on mode
function setSlotDraggableForCards(slot){
  // Only allow HTML5 drag-from-slot when NOT editing layout
  if (!editingLayout && slot.classList.contains('filled')) slot.setAttribute('draggable','true');
  else slot.removeAttribute('draggable');
}

  
/* ===== state ===== */
let INVENTORY = [];          // user inventory
let selectedCard = null;     // for tap-to-place on mobile
const placedSet = new Set(); // "card_id::serial?" to block duplicates

let TOTAL = 0;               // server-reported total for current filters
let PAGE = 1;                // client-side page for the side grid
let PAGE_SIZE = 48;          // how many to show per page in the side grid
  
const keyOf = (it) => `${it.card_id}::${it.serial ?? ''}`;

/* ===== API ===== */
async function callApi(action, payload){
  const ctl = new AbortController();
  const t = setTimeout(()=>ctl.abort(), 24000);
  try{
    const res = await fetch(API_BASE, {
      method:'POST',
      headers:{
        'Content-Type':'application/json',
      },
      body: JSON.stringify({ action, ...payload }),
      signal: ctl.signal
    });
    const text = await res.text();
    if (!res.ok) throw new Error(text || ('HTTP '+res.status));
    const body = JSON.parse(text);
    if (body.ok === false) throw new Error(body.error || 'Request failed');
    return body.data ?? body;
  } finally { clearTimeout(t); }
}


/* ====  filter ==== */
function populateFilters(facets){
  // ----- Club -----
  const clubEl = $('club');
  if (clubEl){
    const cur = clubEl.value || 'ALL';
    let clubs = [], hasNone = false;

    if (facets?.clubs) {                 // preferred: from API
      clubs   = [...facets.clubs];
      hasNone = !!facets.hasNone;
    } else {                              // fallback: derive from loaded items
      const allClubs = INVENTORY.map(i => (i.club||'').trim());
      hasNone = allClubs.some(c => !c);
      clubs   = Array.from(new Set(allClubs.filter(Boolean))).sort((a,b)=>a.localeCompare(b));
    }

    clubEl.innerHTML =
      '<option value="ALL">Club: ALL</option>' +
      (hasNone ? '<option value="">(none)</option>' : '') +
      clubs.map(c => `<option value="${c}">${c}</option>`).join('');

    if ([...clubEl.options].some(o => o.value === cur)) clubEl.value = cur;
  }

  // ----- Rarity -----
  const rarEl = $('rarity');
  if (rarEl){
    const cur = rarEl.value || 'ALL';
    const rarities = facets?.rarities
      || Array.from(new Set(INVENTORY.map(i => (i.rarity||'').trim()).filter(Boolean))).sort((a,b)=>a.localeCompare(b));
    rarEl.innerHTML = '<option value="ALL">Rarity: ALL</option>' +
      rarities.map(r => `<option value="${r}">${r}</option>`).join('');
    if ([...rarEl.options].some(o => o.value === cur)) rarEl.value = cur;
  }

  // ----- Position -----
  const posEl = $('position');
  if (posEl){
    const cur = posEl.value || 'ALL';
    const positions = facets?.positions
      || Array.from(new Set(INVENTORY.map(i => (i.position||'').trim()).filter(Boolean))).sort((a,b)=>a.localeCompare(b));
    posEl.innerHTML = '<option value="ALL">Position: ALL</option>' +
      positions.map(p => `<option value="${p}">${p}</option>`).join('');
    if ([...posEl.options].some(o => o.value === cur)) posEl.value = cur;
  }
}
  

/* ===== inventory ===== */
function renderInventory(){
  const root = $('inv'); if (!root) return;
  root.innerHTML = '';

  // (We already fetched with club applied; keep a light client check in case user toggles club very quickly)
  const clubSel = v('club','ALL'); // '' means (none)
  let list = (clubSel === 'ALL') ? INVENTORY : INVENTORY.filter(it => it.club === clubSel);

  // paginate
  const pages = Math.max(1, Math.ceil(list.length / PAGE_SIZE));
  PAGE = Math.min(Math.max(1, PAGE), pages);
  const view = list.slice((PAGE-1)*PAGE_SIZE, PAGE*PAGE_SIZE);

  // draw
  for (const it of view){
    const k = `${it.card_id}::${it.serial ?? ''}`;
    card.dataset.k = k;
    if (placedSet.has(k)) card.classList.add('dim');
    const card = document.createElement('div');
    card.className = 'card';
    card.setAttribute('draggable','true');
    card.innerHTML = `
      <img class="thumb" src="${it.image||''}" alt="${it.name||it.card_id||''}"/>
      <div class="meta">
        <div class="name">${it.name || it.card_id}</div>
        <div class="muted">${[it.rarity, it.position || it.type, it.club || '‚Äî'].filter(Boolean).join(' ‚Ä¢ ')}</div>
      </div>`;
    const img = card.querySelector('img.thumb'); if (img) img.setAttribute('draggable','false');

    if (typeof cacheImage === 'function') cacheImage(it);

    // DnD + click select
    card.addEventListener('dragstart', (ev)=>{
      ev.dataTransfer.setData('text/plain', JSON.stringify(it));
      ev.dataTransfer.effectAllowed = 'copy';
      selectedCard = it;
    });
    card.addEventListener('click', ()=>{
      selectedCard = it;
      document.querySelectorAll('#inv .card').forEach(n=>n.style.outline='');
      card.style.outline = '2px solid #38bdf8';
    });

    if (placedSet?.has?.(`${it.card_id}::${it.serial ?? ''}`)) card.classList.add('dim');
    root.appendChild(card);
  }

  // pager UI (optional elements)
  const info = $('pgInfo'); if (info) info.textContent = `${PAGE} / ${pages}`;
  if ($('pgPrev')) $('pgPrev').disabled = (PAGE <= 1);
  if ($('pgNext')) $('pgNext').disabled = (PAGE >= pages);
}

/* ===== load inventory (with loader) ===== */
async function loadInventory(){
  const user_id = v('user_id','').trim();
  if (!user_id) { alert('Enter user ID'); return; }

  // show loader + guard UI
  startBusy('Loading inventory‚Ä¶');
  setUiDisabled(true);

  try {
    // build query from current filters
    const params = {
      user_id,
      rarity:   v('rarity','ALL')   || 'ALL',
      position: v('position','ALL') || 'ALL',
      club:     v('club','ALL')     || 'ALL',
      unique_only: false
    };

    const api = (window.callApi || window.callCollection);
    if (!api) throw new Error('No API function (callApi/callCollection) found');

    // fetch ALL pages (server caps page_size at 96)
    let page = 1, pageSize = 96, items = [], total = null, balances = null, facets = null;
    while (true) {
      const data = await api('collection', { ...params, page, page_size: pageSize });
      if (!facets && data?.facets)   facets   = data.facets;
      if (!balances && data?.balances) balances = data.balances;
      const batch = Array.isArray(data?.items) ? data.items : [];
      if (total === null) total = Number(data?.total ?? batch.length);
      items.push(...batch);
      if (items.length >= total || batch.length < pageSize) break;
      page++;
    }

    // normalize to client shape
    INVENTORY = items.map(x => ({
      card_id:  x.card_id,
      name:     x.name,
      type:     x.type,
      rarity:   x.rarity || '',
      position: x.position || '',
      club:     (x.club ?? '').trim(),
      image:    x.image_url || x.image_ref || '',
      serial:   (x.serial===''||x.serial==null) ? null : Number(x.serial)
    }));

    // balances (optional UI)
    if (balances){
      if ($('tickets')) $('tickets').textContent = balances.tickets ?? '0';
      if ($('tokens'))  $('tokens').textContent  = balances.tokens  ?? '0';
    }

    // filters and first render
    populateFilters(facets);
    PAGE = 1;
    renderInventory();

    toast('Inventory loaded ‚úî');
  } catch (err) {
    console.error(err);
    toast('Inventory load failed: ' + (err?.message || err), true);
  } finally {
    stopBusy();
    setUiDisabled(false);
  }
}



  
async function ensureImagesFor(cardIds){
  // We only need serial-agnostic images to draw the formation
  const missing = cardIds.filter(id => !IMG_CACHE.has(`${id}::`));
  if (missing.length === 0) return;

  // Try to fill from INVENTORY first (if it was loaded later)
  for (const it of INVENTORY) {
    const img = it.image || '';
    if (img) {
      IMG_CACHE.set(`${it.card_id}::`, img);
    }
  }
  const stillMissing = missing.filter(id => !IMG_CACHE.has(`${id}::`));
  if (stillMissing.length === 0) return;

  // Fallback: fetch the full cards catalog once and map card_id -> image
  const payload = await callApi('cards', {}); // same action used by the Dex page
  const all = Array.isArray(payload?.items) ? payload.items
            : (Array.isArray(payload) ? payload : []);
  for (const c of all) {
    const img = c.image_url || c.image_ref || '';
    if (img) IMG_CACHE.set(`${c.card_id}::`, img);
  }
}




/* ===== slots ===== */
const allSlots = () => Array.from(document.querySelectorAll('.slot'));

function attachDnD(){
  for (const slot of allSlots()){
    slot.addEventListener('dragover', (e)=>{ e.preventDefault(); slot.classList.add('hover'); });
    slot.addEventListener('dragleave', ()=> slot.classList.remove('hover'));
    // Single click to PLACE only when not editing and a card is selected
    slot.addEventListener('click', (e)=>{
      if (editingLayout) return;          // do nothing in edit mode
      if (!selectedCard) return;          // only place when a card is selected
      placeInSlot(slot, selectedCard);
    });
    slot.addEventListener('contextmenu', (e)=>{ e.preventDefault(); clearSlot(slot); markInventoryDim(); updatePlacedCount(); });

    slot.addEventListener('dblclick', ()=>{
      if (!slot.classList.contains('filled')) return;
      const it = {
        card_id: slot.dataset.cardId,
        serial:  slot.dataset.serial===''? null : Number(slot.dataset.serial),
        image:   slot.querySelector('.thumb')?.src || '',
        name:    '', rarity:'', position:'', club:''
      };
      openCardModal(it);
    });
    
    // allow dragging a filled slot as a "card" source (when NOT editing layout)
    slot.addEventListener('dragstart', (e)=>{
      if (editingLayout || !slot.classList.contains('filled')) { e.preventDefault(); return; }
      const it = {
        card_id: slot.dataset.cardId,
        serial:  slot.dataset.serial===''? null : Number(slot.dataset.serial),
        image:   slot.querySelector('.thumb')?.src || ''
      };
      e.dataTransfer.setData('text/plain', JSON.stringify(it));
      e.dataTransfer.effectAllowed = 'move';
      slot.dataset.draggingFrom = '1';
    });
    slot.addEventListener('dragend', ()=> { delete slot.dataset.draggingFrom; });
    // in your existing drop handler for slots, replace the body with:
    slot.addEventListener('drop', (e)=>{
      e.preventDefault(); slot.classList.remove('hover');
      let it; try{ it = JSON.parse(e.dataTransfer.getData('text/plain')||'{}'); }catch{ it=null; }
      if (!it || !it.card_id) return;

      const isManagerSlot = (slot.dataset.slot === 'MANAGER');
      const isManagerCard = (String(it.type||'').toLowerCase() === 'manager') ||
                            (String(it.position||'').toLowerCase() === 'manager');
    
      if (ENFORCE_MANAGER){
        if (isManagerSlot && !isManagerCard){ toast('Drop a manager card here', true); return; }
        if (!isManagerSlot && isManagerCard){ toast('Managers can only go into the Manager slot', true); return; }
      }

      const src = document.querySelector('.slot[data-dragging-from="1"]'); // moving from another slot?
      if (src && src !== slot){
        if (slot.classList.contains('filled')){
          // swap: put target‚Äôs card back into the source
          const tCard = {
            card_id: slot.dataset.cardId,
            serial:  slot.dataset.serial===''? null : Number(slot.dataset.serial),
            image:   slot.querySelector('.thumb')?.src || ''
          };
          placeInSlot(src, tCard);
        } else {
          // pure move: clear the source
          clearSlot(src);
        }
      }
      placeInSlot(slot, it);
    });
  }
  const trash = document.getElementById('trash');
  if (trash){
    trash.addEventListener('dragover', (e)=>{ e.preventDefault(); trash.classList.add('hover'); });
    trash.addEventListener('dragleave', ()=> trash.classList.remove('hover'));
    trash.addEventListener('drop', (e)=>{
      e.preventDefault(); trash.classList.remove('hover');
      const src = document.querySelector('.slot[data-dragging-from="1"]');
      if (src) { clearSlot(src); markInventoryDim(); updatePlacedCount(); }
    });
  }
}

function placeInSlot(slot, it){
  const k = keyOf(it);
  const prevKey = slot.dataset.kEq || '';
  // block duplicates (unless re-placing the same card back into same slot)
  if (placedSet.has(k) && k !== prevKey){ shake(slot); return; }

  if (prevKey) placedSet.delete(prevKey);

  const img = slot.querySelector('.thumb');
  if (img) img.src = it.image || '';
  slot.classList.add('filled');
  slot.dataset.cardId = it.card_id;
  slot.dataset.serial = (it.serial ?? '');
  slot.dataset.kEq = k;
  setSlotDraggableForCards(slot);

  placedSet.add(k);
  markInventoryDim();
  updatePlacedCount();
}

function clearSlot(slot){
  const kPrev = slot.dataset.kEq;
  if (kPrev) placedSet.delete(kPrev);
  slot.dataset.cardId=''; slot.dataset.serial=''; slot.dataset.kEq='';
  const img = slot.querySelector('.thumb'); if (img) img.src='';
  slot.classList.remove('filled');
  setSlotDraggableForCards(slot);
}

function markInventoryDim(){
  document.querySelectorAll('#inv .card').forEach(node=>{
    const k = node.dataset.k || '';
    if (k && placedSet.has(k)) node.classList.add('dim');
    else node.classList.remove('dim');
  });
}

function updatePlacedCount(){ const pc=$('placedCount'); if (pc) pc.textContent = placedSet.size; }
function shake(el){
  el.style.transition='transform .08s';
  el.style.transform='translateX(4px)';
  setTimeout(()=>el.style.transform='translateX(-4px)', 80);
  setTimeout(()=>el.style.transform='translateX(0)', 160);
}

/* ===== shapes: relabel only (keep same compact layout) ===== */
// align 4-3-3 to your initial slot labels so loading saved data works
//REMOVED NOW
  //const SHAPES = {
  //"4-3-3": ["GK","LB","LCB","RCB","RB","LCM","CM","RCM","LW","ST","RW"],
  //"4-2-3-1": ["GK","LB","LCB","RCB","RB","DM1","DM2","LAM","CAM","RAM","ST"],
  //"3-5-2": ["GK","LCB","CB","RCB","LM","LCM","CM","RCM","RM","ST1","ST2"],
  //"4-4-2": ["GK","LB","LCB","RCB","RB","LM","LCM","RCM","RM","ST1","ST2"]
//};
  
//function relabelForShape(){
  //const shapeSel = $('shape');
  //const labels = SHAPES[shapeSel ? shapeSel.value : '4-3-3'] || SHAPES["4-3-3"];
  //const pitchSlots = allSlots().filter(s => !s.closest('#bench'));
  //pitchSlots.forEach((s,i)=>{
    //clearSlot(s);
    //const lbl = s.querySelector('.lbl');
    //if (lbl) lbl.textContent = labels[i] || ('S'+(i+1));
   // s.dataset.slot = lbl ? lbl.textContent : (s.dataset.slot || ('S'+(i+1)));
  //});
 // placedSet.clear(); updatePlacedCount(); markInventoryDim();
//}

function toggleLayoutEdit(){
  editingLayout = !editingLayout;
  allSlots().forEach(s=>{
    const isPitchSlot = !!s.closest('#pitch');
    s.classList.toggle('moveable', editingLayout && isPitchSlot);
    setSlotDraggableForCards(s);

    s.removeEventListener('mousedown', startPan);
    s.removeEventListener('touchstart', startPan);
    if (editingLayout && isPitchSlot){
      s.addEventListener('mousedown', startPan);
      s.addEventListener('touchstart', startPan, {passive:false});
    }
  });
  const btn = document.getElementById('btnEdit');
  if (btn) btn.textContent = editingLayout ? 'Stop Editing' : 'Edit Layout';
}





function toggleSnap(){
  SNAP_GRID = !SNAP_GRID;
  const b = document.getElementById('btnGrid');
  if (b) b.textContent = SNAP_GRID ? 'Snap: On' : 'Snap: Off';
}

// drag-to-move a slot (with threshold + snap)
function startPan(e){
  if (!editingLayout) return;                  // never move unless editing
  if (e.button !== undefined && e.button !== 0) return; // left click only
  e.preventDefault();

  const slot = e.currentTarget;
  if (!editingLayout || !slot.closest('#pitch')) return; // <- only pitch
  const pitch = document.getElementById('pitch');
  const rect = pitch.getBoundingClientRect();

  const pt = (ev)=>{ const p = ev.touches ? ev.touches[0] : ev; return {x:p.clientX-rect.left, y:p.clientY-rect.top}; };
  const start = pt(e);

  const curLeftPct = parseFloat(slot.style.left) || (slot.offsetLeft / pitch.clientWidth * 100);
  const curTopPct  = parseFloat(slot.style.top)  || (slot.offsetTop  / pitch.clientHeight * 100);
  const startLpx = curLeftPct/100 * pitch.clientWidth;
  const startTpx = curTopPct /100 * pitch.clientHeight;

  let moved = false;
  const DRAG_THRESHOLD = 8;

  function move(ev){
    ev.preventDefault();
    const cur = pt(ev);
    const dx = cur.x - start.x, dy = cur.y - start.y;
    if (!moved && (dx*dx + dy*dy) < DRAG_THRESHOLD*DRAG_THRESHOLD) return;
    moved = true;

    let nx = startLpx + dx;
    let ny = startTpx + dy;

    const halfW = slot.offsetWidth/2, halfH = slot.offsetHeight/2;
    nx = Math.max(halfW, Math.min(nx, pitch.clientWidth  - halfW));
    ny = Math.max(halfH, Math.min(ny, pitch.clientHeight - halfH));

    let nxPct = (nx / pitch.clientWidth)  * 100;
    let nyPct = (ny / pitch.clientHeight) * 100;

    if (SNAP_GRID){
      nxPct = snapPct(nxPct, GRID.xStepPct);
      nyPct = snapPct(nyPct, GRID.yStepPct);
    }

    slot.style.left = nxPct + '%';
    slot.style.top  = nyPct + '%';
    slot.style.transform = 'translate(-50%,-50%)';
  }
  function end(){
    window.removeEventListener('mousemove', move);
    window.removeEventListener('mouseup', end);
    window.removeEventListener('touchmove', move);
    window.removeEventListener('touchend', end);
  }
  window.addEventListener('mousemove', move);
  window.addEventListener('mouseup', end);
  window.addEventListener('touchmove', move, {passive:false});
  window.addEventListener('touchend', end);
}



  
/* ===== save / load ===== */
function collectSlots(){
  const pitch = document.getElementById('pitch');
  return allSlots().map(s=>{
    const inPitch = !!s.closest('#pitch');
    const cid = s.dataset.cardId || null;
    const ser = s.dataset.serial || '';

    let out = {
      slot_id: (s.dataset.slot || '').trim(),
      card_id: cid,
      serial:  ser==='' ? null : Number(ser)
    };

    if (inPitch){
      const leftPct = parseFloat(s.style.left) || (s.offsetLeft / pitch.clientWidth * 100);
      const topPct  = parseFloat(s.style.top)  || (s.offsetTop  / pitch.clientHeight * 100);
      out.x_pct = +leftPct.toFixed(2);
      out.y_pct = +topPct.toFixed(2);
    }
    return out;
  });
}



async function saveFormation(){
  const user_id = v('user_id').trim();
  const name    = v('fname').trim();
  if (!user_id || !name){ alert('user id + formation name required'); return; }

  const shape = 'free';                 // we removed picker
  const slots = collectSlots();

  startBusy('Saving formation‚Ä¶'); setUiDisabled(true);
  try{
    await callApi('formation_save', { user_id, name, shape, slots });

    // Verify by reading back (optional but confirms persistence)
    const verify = await callApi('formation_get', { user_id, name });
    if (!verify || !Array.isArray(verify.slots)) throw new Error('Save verification failed');

    toast('Saved ‚úî');
  } catch(err){
    console.error(err);
    toast('Save failed: ' + (err?.message || err), true);
  } finally {
    stopBusy(); setUiDisabled(false);
  }
}


async function loadFormation(){
  const user_id = v('user_id').trim();
  const name    = v('fname').trim();
  if (!user_id || !name){ alert('enter user id & formation name to load'); return; }

  startBusy('Loading formation‚Ä¶'); setUiDisabled(true);
  try{
    const data = await callApi('formation_get', { user_id, name });
    if (data?.error){ toast('Not found', true); return; }

    // NEW: make sure we have images for all cards in the saved formation
    const needIds = Array.from(new Set((data.slots||[])
                      .filter(s => s.card_id)
                      .map(s => s.card_id)));
    await ensureImagesFor(needIds);

    placedSet.clear(); allSlots().forEach(clearSlot);

    (data.slots || []).forEach(s=>{
      const slotEl = allSlots().find(x => String(x.dataset.slot)===String(s.slot_id));
      if (!slotEl) return;

      const inPitch = !!slotEl.closest('#pitch');
      if (inPitch && typeof s.x_pct === 'number' && typeof s.y_pct === 'number'){
        slotEl.style.left = s.x_pct + '%';
        slotEl.style.top  = s.y_pct + '%';
        slotEl.style.transform = 'translate(-50%,-50%)';
      } else if (!inPitch){
        slotEl.style.left = ''; slotEl.style.top = ''; slotEl.style.transform = '';
      }

      if (!s.card_id) return;
      const meta = INVENTORY.find(it => it.card_id===s.card_id && String(it.serial ?? '')===String(s.serial ?? ''));
      const imgEl = slotEl.querySelector('.thumb');

      // Prefer inventory image if present; else use cached catalog image
      let src = meta?.image || IMG_CACHE.get(`${s.card_id}::`) || '';
      if (imgEl && src) { imgEl.src = src; imgEl.setAttribute('draggable','false'); }

      slotEl.classList.add('filled');
      slotEl.dataset.cardId = s.card_id;
      slotEl.dataset.serial = (s.serial ?? '');
      slotEl.dataset.kEq = `${s.card_id}::${s.serial ?? ''}`;
      placedSet.add(slotEl.dataset.kEq);
      setSlotDraggableForCards(slotEl);
    });

    updatePlacedCount(); markInventoryDim();
    toast('Loaded ‚úî');
  } catch(err){
    console.error(err);
    toast('Load failed: ' + (err?.message || err), true);
  } finally{
    stopBusy(); setUiDisabled(false);
  }
}



async function listFormations(){
  const user_id = v('user_id').trim();
  if (!user_id){ alert('enter user id first'); return; }
  startBusy('Listing formations‚Ä¶'); setUiDisabled(true);
  try{
    const data = await callApi('formation_list', { user_id });
    if (!data.items?.length){ alert('No saved formations'); return; }
    alert('Saved formations:\n' + data.items.map(x=>`${x.name} ‚Äî ${new Date(x.ts).toLocaleString()}`).join('\n'));
  } catch(err){
    console.error(err);
    toast('List failed: ' + (err?.message || err), true);
  } finally{
    stopBusy(); setUiDisabled(false);
  }
}

function clearAll(){
  allSlots().forEach(clearSlot);
  placedSet.clear(); updatePlacedCount(); markInventoryDim();
}

/* ===== boot ===== */
document.addEventListener('DOMContentLoaded', ()=>{
  const u = new URLSearchParams(location.search).get('u');
  if (u && $('user_id')) $('user_id').value = u;

  attachDnD();

  on('btnSearch','click',  loadInventory);
  on('btnRefresh','click', loadInventory);         // ‚úÖ was renderInventory

  on('btnSave','click',    saveFormation);
  on('btnLoad','click',    loadFormation);
  on('btnList','click',    listFormations);
  on('btnClear','click',   clearAll);
  // Filters should RE-FETCH, not just repaint:
  on('club','change',   ()=>{ PAGE = 1; loadInventory(); });     // ‚úÖ was renderInventory
  on('rarity','change', ()=>{ PAGE = 1; loadInventory(); });     // ‚úÖ was renderInventory
  on('position','change',()=>{ PAGE = 1; loadInventory(); });    // ‚úÖ was renderInventory
  //on('shape','change', relabelForShape);
  on('btnEdit','click',  toggleLayoutEdit);
  on('btnGrid','click',  toggleSnap);

  const prev = $('pgPrev'), next = $('pgNext');
  if (prev) prev.addEventListener('click', ()=>{ PAGE = Math.max(1, PAGE-1); renderInventory(); });
  if (next) next.addEventListener('click', ()=>{ PAGE = PAGE+1; renderInventory(); });
});

</script>

</body>
</html>
